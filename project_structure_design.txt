 * Для чего нужна поддержка динамической загрузки:
 * - возможность компоновать диструбутив программы с различными фичами в зависимости от заказчика
 * - поддержка загрузки плагинов из базы (???? это возможность) - отказываемся - знаем состав приложения на старте и оно не меняется!
 * - грузить бандлы в рантайме в зависимости от рантайм объекта, например из базы или по запросу - отказываемся - знаем состав приложения на старте и оно не меняется!
TODO: обдумать ещё раз - вещь полезная, например


1. Апи
========================================================================================================================================================================
Содержит в отдельных модулях все интерфейсы всех бандлов
========================================================================================================================================================================










2. Бандлы
========================================================================================================================================================================
Реализации интерфейсов бандлов + зависимости только по апи от других бандлов, от коммон библиотек и от 3-rd part библиотек
Пишем градл плагин, который в манифест выкидывает все сервисы которые экспортирует бандл.
Необходимо предусмотреть DI в рамках самого банда для удобства работы с кодом.
Для этого нужно accessType назначать на интерфейс, а не на бин. Т.к. один бин может имплементить и внешний
интерфейс (тот что есть в api) и внутренний, тот, которого нет в api
Для api зависимостей, которые бандл реализует - accessType будет public,
а для всех остальных, в том числе и implemented и стандартные java интерфейсы - private (доступ только внутри бандла)
Транзитивные зависимости в API не учитываются и так же будут PRIVATE. Если бандл реализует также
и сервисы из транзитивных от API зависемостей - он должен явно их подключить через api

----------------------------------- Гипотеза о упаковки бандла ----------------------------
Было бы не плохо чтобы при сборке
была возможность указать вытащить все 3-rd сторонние библиотеки через аналог dependencyManagement в maven-е
в каталог lib (на уровне плагина и приложения)
А те зависимости что не указаны в dependencyManagement оставить на уровне бандла и включить в jar
- что делать с common - вкомпиливать по-умолчанию в каждый банл
- что делать с api и их транзитивными зависимостями (????)  (-)
	->> на уровне бандла не включаем их вообще и api типа и implementation типа так же (зависит от bundle.embeddedDependencies флага)
	но потом на уровне плагина и приложения их нужно включить вместе с их сторонними, транзитивными либами (-)

Но чтобы всё это работало необходимо чтобы dependencyManagement был разрезолвен.
Иначе возможен кейс мы не сможем на уровне бандла понять эта специфическая зависимость или
же разрезолвленая и подменённая из dependencyManagement.

С другой стороны любую специфическую зависимость можно вынести в dependencyManagement
и тогда она может быть разрезолвлена относительно всего проекта заранее и её не нужно будет включать в бандл вообще.
Следовательно нужно запретить использовать зависимости не добавив их в dependencyManagement(-) - не любую, а что если нужны 2 версии одной и той же

С другой стороны, каждый бандл имеет срез из dependencyManagement, который может разрезолвиться совсем по-другому,
нежели полный набор из dependencyManagement, тогда можно обратиться к результату резолва dependencyManagement,
и посмотреть что там содержится все зависимости и нужной версии, в противном случае ломать билд,
заставляя пользователя руками включить нужную версию зависимости в бандл или же
прописать явно в dependencyManagement транзитивную версию зависимости для той зависимости в которой произошла подмена версии.
Например как тут:

---------------- dependencyManagement резолвинг ------------------------
+--- project :api:api-neural-network
|    \--- com.google.code.findbugs:jsr305:3.0.2 <<<<<<<<<<-------------- явно зависим
+--- com.google.guava:guava:23.6-jre
|    +--- com.google.code.findbugs:jsr305:1.3.9 -> 3.0.2  <<<<<<<<<<<<<<<<<<<<----------------- не явно и произошла подмена

------------- резолвинг конкретного бандла ---------------------
+--- com.google.guava:guava:23.6-jre
|    +--- com.google.code.findbugs:jsr305:1.3.9  <<<<<<<<<<<<<<<<<<<<----------------- опракинем билд, заставив явно указать com.google.code.findbugs:jsr305:3.0.2


А что если какому-то плагину всё-таки нужно использовать отличную от общей версию сторонней либы
по причине того что в ней например есть нужная функциональность а в новой версии её уже нет,
а все в проекте используют уже новую? (-)
Возможно есть смысл плагину просить тогда явно включить зависимость определённой версии,
тогда она не будет проверяться и попадёт в jar этого бандла.

Минус вышеописанного подхода в том что придётся разделять сторонние либы по класс лоадерам.
И даже если это сделать правильно: [
	позволяет бандлу явно подключать транзитивную или обычную зависимость ОТЛИЧНОЙ от dependencyManagement версии,
	тогда можно просканировать всё дерево зависимостей вверх, где присутсвует данная зависимость
	и положить на уровень бандла все эти либы. А класс лоадер уровня бандла сначала смотрит у себя,
	а потом делегирует паренту.
]
Есть вероятность получить серию LinkageError ошибок.
Например, понятно что общие либы api должны лежать так же в main класс лоадере, например бандл
хочет перегрузить эту зависимость - получит предупреждение и явно пропишет в gradle.build себя.
Когда он обратиться к api то бандл лоадер делегирует main класс-лоадер загрузку,
и когда запроситься зависимый класс который находится в перегруженной нами либе,
то его загрузит main!!!!! класс лоадер. Может и норма. Но если это дефолтный метод интерфейса,
то возможен LinkageError!
Но как тогда подложить в готовое приложение бандл другой версии, например? Придётся смотреть его зависимости
и подкладывать их так же. Но пускай приложение имеет ядро, и все его бандлы _не_ самодостаточны в плане 3rd party
зависимостей. А вот приложение и плагины - самодостаточны.
Каждый бандл в манифесте иммет список зависимостей.
Все эти зависимости при сборке приложения или плагина кладутся на уровень плагина или приложения соответственно.
Таким образом уменьшаем объём дистрибутива.
Но при работе общие библиотеки не шарятся между класс-лоадерами. ==>>> Оверхед на кол-во классов загруженных в рантайме.

dependency-management теперь является консультационным. Он содержит в себе совместимые версии зависимостей.
--------------------------------------------------------------------------------------------
========================================================================================================================================================================







3. Плагины
========================================================================================================================================================================
У плагина нет кода - он просто оборачивает какой-либо бандл или бандлы.

Плагин в градле декларирует те бандлы, сервисы которых он экспортит.
Соответвенно их можно дёргать из вне плагина.
api project(':bundles:neural-network-core')

Реализации этих интерфейсов в качестве бандлов И всех зависищих бандлов
implementation project(':bundles:comprehensive-serializer:1.0-SNAPSHOT')

Так же указываем в кастомный плагин, который будет готовить дистрибутив, exclude list тех API реализация которых должны браться из вне
и не вкомпиливаться в данный плагин (как опцию, а противном случае просто предупреждение о тех ап что не реализованы).

Пишем плагин для градла PluginPackager, который готовит jar архив, включает в него:
- api - все апи (рекурсивно)
- bundles - все бандлы
- libs - все сторонние либы
- манифест файл в котором описаны те бандлы, которые экспортит плагин и implementation-lifecycleType бандл

(*)
Так же плагин проверяет есть ли для всех api реализации и выводит предупреждение!
и кидает ошибку если каких-либо реализаций нет.
(!) ПРОБЛЕМА: как понять из api что там за сервисы и как искать для них реализации??? (+)
Можно имперически так: имеем мапу api-jar -> список интерфейсов. Так же у нас есть все сервисы.
Идём по интерфейсам каждого сервиса - ищем их в списке интерфейсов, если нашли - составляем пару:
api-jar -> bundle-jar, который реализует данное апи.
Из всех оставшихся вычитаем exclude list и полученный список выводим предупреждение.
Такой подход не учитывает бандл + весрию, запрашиваемого в рантайме . Но и фиг с ним.

------>>>>>> ИЛИ по другому - у нас есть набор бандлов каждый из которых в api указывает те интерфейсы, что он реализует
и те что ему нужны для работы, делаем (все интерфейсы implemented во всех бандлах) - (все интерфейсы api во всех бандлах)
- получаем те интерфейсы что требуются но не включены в плагин:
 выдаём warning при сборке. Вполне может быть что приложение подключило api зависимсть на какой-то плагин,
 но в рантайме не будет им пользовться пока это плагин не подключен (-)


Так же если есть зависимость на другие плагины, то тут их нужно указать.
Эту информацию нужно прописать в манифесте.

----------------------------------- Гипотеза о упаковки плагина ----------------------------
Было бы не плохо чтобы при сборке всего приложения без плагинов
была возможность указать вытащить все 3-rd сторонние библиотеки через аналог dependencyManagement в maven-е
в каталог lib. Но чтобы была настройка в самом плагине делать так или нет.
Если нет - это значит плагин будет полагаться на то что зависимости присутствуют в главной программе,
куда плагин будет подключаться.
А те зависимости что не указаны в dependencyManagement оставить на уровне бандла.

Смотрим от каких api зависят все бандлы и вытаскиваем их в каталог, а их транзитивные зависимости,
если есть - в общих каталог 3-rd party уровня плагина (-) ??? тут нужно подумать
над этим как они будут подключаться к приложению чтобы не было конфликтов (jar-hell)
уровня сторонних либ как транзитивных зависимостей интерфейсов. (-)
--------------------------------------------------------------------------------------------
========================================================================================================================================================================







4. Программы
========================================================================================================================================================================
У программы может быть собственный код но по сути по своей структуре не сильно отличающийся от обычного бандла.

В gradle файле любого приложения указываем те core и framework бандлы которые необходимы и достаточны для его старта.
И обязательно указываем стартер!!!!:
implementation project(':applications:application-starter')

Подключаем плагин проверки набора бандлов и их целостности: (*)
Так же програмный плагин должен сформировать следующую структуру:
- api
- core_bundles
- core_bundles\app <<<--- тут лежит в качестве отдельного бандла скомпилированный код приложения, если у приложения он был
- plugins
- lib\common <<<<------------ тут 3rd party зависимости общие на весь проект (пришли как транзитивные от api)
- lib\wda <<<<---- тут common зависимости проекта
- lib  <<<<<--- все зависимости от всех бандлов, каждый бандл знает какую именно ему грузить по манифесту
- conf\program.properties <<<<<---- вытаскиваем из ресурсов программы - используется при старте стартером
- bin/application-starter.jar
- bin/start/stop.(sh/bat)
- bin/install_plugin/uninstall_plugin.(bat/sh)


Про API:
Сборка
На уровне приложения или плагина ВСЕГДА вытаскиваем и кладём в папку api и lib все интерфейсы из всех бандлов и их зависимости
Так же версии api в плагинах так же должны быть сопоставимы с приложением куда он подключается, даже если api используется
исключительно внутри самого плагина.
Важно понимать что так же как и версии апи должны быть общими на всё приложение так же и их сторонние либы из них должны быть общими на всё приложение.
Следовательно API должны иметь по миниуму сторонних зависимостей.
Если нужно в готовую систему подложить api версии 2 - то или пересобираем всё приложение и перезапускаем его
или же добавляем методы, делая их дефолтными для того чтобы другие реализации изменённого интерфейса не упали (отдаём на совесть разработчика).
ВО время сборки приложения или плагина - гарантируем что все используемые api одной версии.
	(
		для 3rd-party либ api резолвим их как отдельные проекты и включаем и в бандл и в приложение/плагин
		для этого необходимо dependency резолверу зафорсить использование 3rd-party либ версии api!
	)
ВО время страта приложения смотрим все версии api и грузим наиболее старшую и для сторонних либ так же наиболее старшую.
По прежднему сторонние либы для api перечислены в WDA-Bundle-Api-Dependencies каждого бандла
и находятся или embedded или лежат в lib/common приложения/плагина.

ПРОБЛЕМА ПОДХОДА: в рамках приложения гарантировали использование какой-то сторонней либы и в api и соответсвенно во всех бандлах.
потом подключаем новый бандл или плагин у которого есть новое апи или же существующее, но апнутой версии, (или например релоад бандла с изменённым апи по версии)
у этого api есть зависимость на сторонню либу отличной версии от то что используется в системе, следовательно существующие плагины,
скомпилировнные, протестированные и использующие старую версию сторонне либы вынуждены работать с новой
и тут может быть БАХ (LinkedError)! (-)

06.04.2018 РЕШЕНИЕ:
Идея:
    ___сделать репозиторий крос-программно общих библиотек. И к ним будут пока относиться только сторонние либы, используемые в апи____
Как:
	Запрещаем в api иметь зависимости не релевантные относительно dependencyManagement.
	Следовательно в рамках всего проекта все апи будут принудительно использовать одну и туже версию сторонней либы.
	Когда собираем бандл нужно зафорсить использование только тех версий сторонних либ, которые используются во всех апи.
	(не только в тех апи что он подключил а во ВСЕХ: для этого в бандл плагин можно добавить служебныю конфигурацию зависимости от всех апи,
	разрезолвить её отдельно, получить сторонние либы и сопоставить их с бандловскими и уранить сборку если будет отличие)

	(*PROGRAM TODO*) TODO: как сделать - как в готовом приложении понять от кого мы зависим?
	----
	Во время старта программы сканируем все бандлы, их common либы, все плагины, их коммон либы,
	для всех сторонних либ, отличной версии выдаём предупреждение о том что будет использоваться старшая версия,
	но то что в системе следующие бандлы и плагины используют прошлую версию.
	---
	Во время работы класс грузится сначала с common лоадера, потом с бандла.
	Следовательно, все бандлы должны быть скомпилированы и отлажены с теме, общими с апи, версиями сторонних либ что в dependencyManagement.
Проблема:
	Дописываем новый апи пакет, который вносит новую сторонню либу в common из dependencyManagement, а другие бандлы уже юзают другую, каcтомную версию этой либы,
	следовательно они поломаются, т.к. будут грузить сначала классы через main class loader, который подсунит другую версию
Решение:
	(*PROGRAM TODO*)
	При старте бандла сопоставляем его сторонние зависимости со всеми common зависимостями приложения.
	Если есть расхождения по версиям - даём предупреждение.
	Получив предупреждение можно на свой страх и риск продлжить работу и потенциально получить LinkedError
	Или же отказаться от внесения новой сторонней либы. Или запушить свой апи в общий репозиторий, дождаться
	следующего релиза, где уже будет учтён новый апи и его стороння зависимость и все бандлы так же перейдут на неё. (-)
Проблема:
	В рамках приложения например подключаем зависимость на сторонние бандлы в мавен репозитории, которые несут с собою
	новое api и сторонние коммон либы этого апи. Как результат плагин сборки приложения может проверить все версии
	коммон либ и если найдёт расхождение может сказать в каких бандлах нужно зафорсить использование
	версий коммно либ. Минусы: в рамках подключаемого бандла становиться невозможным изменить его либы,
	т.к. бандл уже собран и оттестирован, а он так же может не учитывать common либы всего приложения, т.к. был собран в другом энвариементе
Решение: просто дать предупреждение, так же как и в рантайме. Причина - очень редка ситуация впринципе использование коммон либ в апи (-)


4.2 conf\program.properties - содержит все свойства запуска контекста в т.ч. те интерфейсы которые будут выставлятся наружу
как микросервисы, но только те что были выставлены в API самой программы + различные доп параметры для соединения: ip:port членов кластера и т.п..
А так же обязательно для всех api которые требуются программе (implementation), но для них нет реализации в onboard
+ для тех что есть, но например другого бандла или другой версии или по другому имени - указываем удалённый кластер от куда их брать,
но поскольку нет возможности отличить сервис в апи от обычного апи над бином - заглушки будут создаваться лениво во время обращения
к удалённому сервису + ip:port членов кластера и т.п..

4.3 Установка и удаление плагинов
Действия возможно только при выключенном приложении.

Нужно учесть что установленные плагины могут регистрировать публичные интерфейсы которыми обычно могут пользоваться другие плагины.
Например пишем core поддержку non-sql-core баз данных, это плагин и не входит в стандартный пакет приложения core.
Далее разрабатываем плагины для casandra, elastic, MongoDB. А так же куча бандлов и плагинов для UI.
Далее если мы удаляем плагин non-sql-core то все остальные плагины, связанные с ним перестанут работать.
Их нужно так же будет удалять, иначе всё приложение не сможет стартануть.
!!!Но у нас нет связи между плагинами, как понять что удалять - НИКАК!!?
Для этого нужно статическое связывание, которого нет и не будет.
Решение - в градловом файле в плагине указываем те плагины от которых зависим.


install_plugin устанавливает плагин следующим образом:
-TODO: api, configuration files
========================================================================================================================================================================





5. Запуск приложения (для локального application context, для micro-service supported - продумать отдельно)
========================================================================================================================================================================
Все бандлы из core_bundles регистрируются в AppCtx с областью видимости - доступны всем.
Создаётся контейнер под бандл со своим класс-лоадером, парентом для которого является рутовый приложения.
Признак бандла - это jar в котором лежит сервис.
Регистрационная запись - это: API class - serviceName - bundleName - bundleVersion - reference_to_access_list_to_plugin -> имя jar + путь к классу + BUNDLE_CONTAINER.

Все бандлы из core_bundles загружаются согласно политики сервисов в них входящий.
Загрузка состоит из:
- если есть сервисы EAGER
- последовательно инстанцируются сервисы в рамках BUNDLE_CONTAINER (класс-лоадера)
- если сервис во время инстациации запрашивает другой сервис - ищу нужную регистрационную запись и начинаю грузить зависищий сервис
	(ТАК ЖЕ НЕОБХОДИМА ПОДДЕРЖКА ЛУПОВ ЗАГРУЗКИ)
- вызываем PostConstruct


Отладка приложения пока что remote debugger-ом


5.1 Подгрузка плагинов.
Загрузка плагинов происходит из plugins каталога.
Все плагины регистрируются в AppCtx с областью видимости:
- доступны всем - те сервисы, которые экспортит плагин
- ограниченный доступ - для всех остальных сервисов, присутствующих в плагине
	Для этого нужно предварительно создать контейнеры бандлов для экспортируемых бандлов, чтобы были класс лоадеры.
	+ Нужна таблица соотвествия BUNDLE_CONTAINER(класс-лоадера) - плагин.
	в reference_to_access_list_to_plugin помещаем название плагина, которому разрешён доступ.
	Когда приходит call на инстанс сервиса - идём по стеку вызова вверх, берём каждый класс лоадер текущего класса - ищем для него название плагина,
	как нашли - смотрю есть ли этот плагин в списке разрешённых - если нет - ServiceAccessException.
Таким образом решается задача разграничения прав доступа к бандлам.
- вызываем PostConstruct


5.2 Жизненный цикл приложения
- AppCtx грузит core бандлы
- AppCtx грузит все плагины
- Делаем топографическую сортировку полученного графа
- Регестрируем ShutdownHook для вызова PostConstruct в топологически отсортированном виде
- Завершаем поток main

5.3 Замечания по реализации логики:
Приложение после прогрузки и старта всех EAGER сервисов завершает main поток AppCtx и вешает ShutdownHook на завершение программы.
Main поток завершается и только если есть процессы не демоны, всё приложение будет работать.
Когда приложение получает сигнал о завершении, оно в обратной топологической сортировке начинает вызывать PreDestroy всем eager сервисам и завершается.
========================================================================================================================================================================





6. Общие библиотеки
========================================================================================================================================================================
см. выше
========================================================================================================================================================================




7. Правила декларации зависимостей градла в модулях:
========================================================================================================================================================================
7.1 Для API модулей:
Модуль апи должен иметь как можно меньше зависимостей от сторонних либ, не должен зависеть от других модулей проекта, за исключением
других апи модулей.

Декларация других апи модулей: api
Декларация 3-rd библиотек: api


7.2 Для бандлов:
Модуль с реализацией какого-либо апи  бандла. Такой бадл и выставляет данное апи.
Так же он подключает другие апи для взаимодействия с системой и с другими бандлами,
коммон библиотеки, 3-rd party библиотеки.

Декларация реализуемого API: api
Декларация API для взаимодействия с системой: implementation
Декларация коммон библиотек и сторонних: implementation


7.3 Для плагинов:
Модуль декларирует те бандлы которые он экспортирует.
Так же у него есть бандлы которые необходимы для его реализации.
Коммон библиотеки, 3-rd party библиотеки.
И так же есть зависимости от других плагинов.

Декларация экспортируемых бандлов и их API соответсвенно: api project(':bundles:neural-network-core')
Декларация бандлов с реализацией, необходимых для взаимодействия с ними экспортируемых бандлов и включённых в поставку плагина: implementation project(':bundles:comprehensive-serializer:1.0-SNAPSHOT')
Декларация зависимости от других плагинов (не обязательно включённых в проект, их могут написать другие команды): TODO


7.3 Для программ:
Модуль декларирует те core и framework бандлы, образующие самодостаточное приложение (без плагинов).
Коммон библиотеки, 3-rd party библиотеки, т.к. может иметь свой код запуска.
Так же включает project(':applications:application-starter') (так же там влючены и ресурсы различные, скрипты запуска и т.п.)

Декларация framework бандлов: implementation (?) или как в плагине api - те что выставляем наружу и implementation - те что для внутренней работы
Декларация коммон и 3-rd party библиотек: implementation
Декларация зависимости на стартер: implementation project(':applications:application-starter')
========================================================================================================================================================================




TODO: переписать с учётом поддержки микросервисной архитектуры
7. Логика загрузки бандлов и инициализации сервисов в них
========================================================================================================================================================================
7.1 Логика загрузки следующая: application-starter создаёт рутовый класс лоадер для апи + коммон, и прогружает их туда,
		потом его наследника - ApplicationContextClassLoader, куда прогружает код ApplicationContext и запускает его
		тот уже за апи и коммон лезит к рутовому, за всем остальным - смотрит у себя

7.2. Собираем все бандлы в виде ResolvedBundleArtifact

7.3. Идём по всем бандлам создаём для каждого Bundle объект

7.3.1 Смотрим сервисы EAGER, нам нужно вызвать для них конструкторы, которые могут зависеть от других
		сервисов - строим граф зависимостей, топографически его сортируем, ищем лупы, если есть - исключение - не можем
		создать контекст!

7.3.2 В топографическом порядке получаем список бандлов, которые должны быть прогружены как EAGER
		 и в этом же порядке делаем Bundle#load() - создание собственного класс лоадера и загрузка в него всех классов бандла + инициализация ApplicationContextHolder для этого бандла

7.3.3 В топографическом порядке вызываем конструктора сервисов из бандла, заворачивая их в прокси объекты! в рамках соответствующего класс лоадера
		и регестрируем в ApplicationContext
		Если во время вызова конструктора будет обращение к другому сервису, то мы должны остановится добавить в граф бандл и сервис от которого
		зависим, снова делаем сортировку, убеждаемся что нет лупа и начинаем вызов конструктора для нижней точки графа, логика рекурсивная
		посути встретив обращение в контексту - мы возвращаемся в пункт 3.1, только учитывая что запрашиваемый сревис у нас теперь как EAGER

7.3.6 Если есть реализация ServiceLifecycle - то вызываем postConstruct

7.3.5 Добавляем этот сервис в контекст со статусом INITIALISED

7.4. Сохраняем полученый граф бинов, который может эвалюцианировать для того что бы была возможность вызвать ServiceLifecycle#preDestroy в нужном порядке

TODO: завершение приложения

========================================================================================================================================================================




8. Релоад бандлов "на горячую" TODO: переписать с учётом микросервисной архитектуры
========================================================================================================================================================================

TODO: подумать над сервис диспетчером

- Поддерживаем именно РЕЛОАД бандлов для возможности пока что отладки, просто выгрузка не поддерживается
- Каждый сервис оборачивается в прокси объект
- Каждый метод сервиса возвращает прокси объект
- Каждый прокси объект подписывается через глобальный event dispatcher на выгрузку/загрузку бандла которому он принадлежит
- При выгрузке бандла - отправляется евент, все прокси подписанные на него обнуляют линки на базовый объект
- Если снова происходит загрузка бандла, посылается новый евент, все прокси его получают и переустанавливают всязи на базовые объекты,\
	если это возможно, если нет (например, объект был создан от корневого сервиса с кучей параметров, то прокси остаётся невалидный)
- Для всех сервисов, владеющих прокси на перегруженный сервис (связь устанавливается в момет когда какой либо сервис запрашивает другой через инъекцию
	или же через appCtx) отправляется ServiceLifecycle#refresh для возможности отреагировать на перегрузку
========================================================================================================================================================================


9. Дизайн собственной графовой базы данных распределённой с распределённом кэшем
========================================================================================================================================================================
TODO
========================================================================================================================================================================


10. Дизайн собственного распределённого процессинга как spark процессинг для трансформации данных и их подготовки как обучающая и тестовая выборка + может использоваться 
для организации workflow получения результатов распознования NN большого объёма данных
========================================================================================================================================================================
TODO
========================================================================================================================================================================










