 * Для чего нужна поддержка динамической загрузки:
 * - возможность компоновать диструбутив программы с различными фичами в зависимости от заказчика
 * - поддержка загрузки плагинов из базы
 * - грузить бандлы в рантайме в зависимости от рантайм объекта, например из базы или по запросу


1. Апи
Содержит в отдельных модулях все интерфейсы всех бандлов

2. Бандлы
Реализации интерфейсов бандлов + зависимости только по апи от других бандлов, от коммон библиотек и от 3-rd part библиотек

3. Плагины
У плагина нет кода - он просто оборачивает какой-либо бандл или бандлы.

Плагин в градле декларирует те бандлы что вытаскивает наружу.
Соответвенно их можно дёгать из вне плагина.
apiElements project(':bundles:neural-network-core')

Реализации этих интерфейсов в качестве бандлов И всех зависищих бандлов
implementation project(':bundles:comprehensive-serializer:1.0-SNAPSHOT')

Так же указываем в кастомный плагин, который будет готовить дистрибутив, exclude list тех API реализация которых должны браться из вне
и не вкомпиливаться в данный плагин.

Пишем плагин для градла PluginBuilder, который готовит jar архив, включает в него:
- все апи (рекурсивно)
- все бандлы
- все сторонние либы
- манифест файл в котором описаны те сервисы, которые экспортит плагин и implementation-type сервисы
Так же плагин проверяет есть ли для всех api реализации - EXCLUDE_LIST
и кидает ошибку если каких-либо реализаций нет.
(!) ПРОБЛЕМА: как понять из api что там за сервисы и как искать для них реализации??? (-)
Можно имперически так: имеем мапу api-jar -> список интерфейсов. Так же у нас есть все сервисы.
Идём по интерфейсам каждого сервиса - ищем их в списке интерфейсов, если нашли - составляем пару:
api-jar -> bundle-jar, который реализует данное апи.
Из всех оставшихся вычитаем exclude list и полученный список выводим ошибку.
Такой подход не учитывает версию бандла запрашиваемого в рантайме. Но и фиг с ним.

4. Программы
TODO: как устроена

4.1 Загрузка (для локального application context, для micro-service supported - продумать отдельно)
Все бандлы из core_bundles регистрируются в AppCtx с областью видимости - доступны для всех.
Создаётся контейнер под бандл со своим класс-лоадером, парентом для которого является рутовый приложения.
Признак бандла - это jar в котором лежит сервис.
Регистрационная запись - это: API class - serviceName - bundleName - bundleVersion - reference_to_access_list_to_plugin -> имя jar + путь к классу + BUNDLE_CONTAINER.

Все бандлы из core_bundles загружаются согласно политики сервисов в них входящий.
Загрузка состоит из:
- если есть сервисы EAGER
- последовательно инстанцируются сервисы в рамках BUNDLE_CONTAINER (класс-лоадера)
- если сервис во время инстациации запрашивает другой сервис - ищу нужную регистрационную запись и начинаю грузить зависищий сервис
	(ТАК ЖЕ НЕОБХОДИМА ПОДДЕРЖКА ЛУПОВ ЗАГРУЗКИ)
- вызываем PostConstruct


4.2 Подгрузка плагинов.
Загрузка плагинов происходит из plugins каталога.
Все плагины регистрируются в AppCtx с областью видимости:
- доступны всем - те сервисы, которые экспортит плагин
- ограниченный доступ - для всех остальных сервисов, присутствующих в плагине
	Для этого нужно предварительно создать контейнеры бандлов для экспортируемых бандлов, чтобы были класс лоадеры.
	+ Нужна таблица соотвествия BUNDLE_CONTAINER(класс-лоадера) - плагин.
	в reference_to_access_list_to_plugin помещаем название плагина, которому разрешён доступ.
	Когда приходит call на инстанс сервиса - идём по стеку вызова вниз берём каждый класс лоадер текущего класса - ищем для него название плагина,
	как нашли - смотрю есть ли этот плагин в списке разрешённых - если нет - ServiceAccessException.
Таким образом решается задача разграничения прав доступа к бандлам.
- вызываем PostConstruct

4.3 Жизненный цикл приложения
- AppCtx грузит core бандлы
- AppCtx грузит все плагины
- Делаем топографическую сортировку полученного графа
- Вызываем PreDestroy

4.4 Замечания по реализации логики:
Приложение после прогрузки и старта всех EAGER сервисов блокирует main поток AppCtx и вешает ShutdownHook на завершение программы.
Когда приложение получает сигнал о завершении, оно в обратной топологической сортировке начинает вызывать PreDestroy всем eager сервисам и завершается.

5. Общие библиотеки
TODO