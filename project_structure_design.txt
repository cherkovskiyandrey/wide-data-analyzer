 * Для чего нужна поддержка динамической загрузки:
 * - возможность компоновать диструбутив программы с различными фичами в зависимости от заказчика
 * - поддержка загрузки плагинов из базы
 * - грузить бандлы в рантайме в зависимости от рантайм объекта, например из базы или по запросу


1. Апи
Содержит в отдельных модулях все интерфейсы всех бандлов

2. Бандлы
Реализации интерфейсов бандлов + зависимости только по апи от других бандлов, от коммон библиотек и от 3-rd part библиотек
Пишем градл плагин, который в манифест выкидывает все сервисы которые экспортирует бандл.


3. Плагины
У плагина нет кода - он просто оборачивает какой-либо бандл или бандлы.

Плагин в градле декларирует те бандлы что вытаскивает наружу.
Соответвенно их можно дёгать из вне плагина.
apiElements project(':bundles:neural-network-core')

Реализации этих интерфейсов в качестве бандлов И всех зависищих бандлов
implementation project(':bundles:comprehensive-serializer:1.0-SNAPSHOT')

Так же указываем в кастомный плагин, который будет готовить дистрибутив, exclude list тех API реализация которых должны браться из вне
и не вкомпиливаться в данный плагин (как опцию, а противном случае просто предупреждение о тех ап что не реализованы).

Пишем плагин для градла PluginBuilder, который готовит jar архив, включает в него:
- api - все апи (рекурсивно)
- bundles - все бандлы
- libs - все сторонние либы
- манифест файл в котором описаны те бандлы, которые экспортит плагин и implementation-type бандл

(*)
Так же плагин проверяет есть ли для всех api реализации и выводит предупреждение!
и кидает ошибку если каких-либо реализаций нет.
(!) ПРОБЛЕМА: как понять из api что там за сервисы и как искать для них реализации??? (+)
Можно имперически так: имеем мапу api-jar -> список интерфейсов. Так же у нас есть все сервисы.
Идём по интерфейсам каждого сервиса - ищем их в списке интерфейсов, если нашли - составляем пару:
api-jar -> bundle-jar, который реализует данное апи.
Из всех оставшихся вычитаем exclude list и полученный список выводим предупреждение.
Такой подход не учитывает бандл + весрию, запрашиваемого в рантайме . Но и фиг с ним.

Так же если есть зависимость на другие плагины, то тут их нужно указать.
Эту информацию нужно прописать в манифесте.


4. Программы
У программы может быть собственный код но по сути по своей структуре не сильно отличающийся от обычного бандла.

В gradle файле любого приложения указываем те core и framework бандлы которые необходимы и достаточны для его старта.
И обязательно указываем стартер!!!!:
compile project(':applications:application-starter')

Подключаем плагин проверки набора бандлов и их целостности: (*)
Так же програмный плагин должен сформировать следующую структуру:
- api
- core_bundles
- core_bundles\app <<<--- тут лежит в качестве отдельного бандла скомпилированный код приложения, если у приложения он был
- plugins
- lib
- conf
- bin/application-starter.jar
- bin/start/stop.(sh/bat)
- bin/install_plugin/uninstall_plugin.(bat/sh)


4.1 Установка и удаление плагинов
Действия возможно только при выключенном приложении.

Нужно учесть что установленные плагины могут регистрировать публичные интерфейсы которыми обычно могут пользоваться другие плагины.
Например пишем core поддержку non-sql-core баз данных, это плагин и не входит в стандартный пакет приложения core.
Далее разрабатываем плагины для casandra, elastic, MongoDB. А так же куча бандлов и плагинов для UI.
Далее если мы удаляем плагин non-sql-core то все остальные плагины, связанные с ним перестанут работать.
Их нужно так же будет удалять, иначе всё приложение не сможет стартануть.
!!!Но у нас нет связи между плагинами, как понять что удалять - НИКАК!!?
Для этого нужно статическое связывание, которого нет и не будет.
Решение - в градловом файле в плагине указываем те плагины от которых зависим.


install_plugin устанавливает плагин следующим образом:
-TODO: api, configuration files


4.2 Запуск приложения (для локального application context, для micro-service supported - продумать отдельно)
Все бандлы из core_bundles регистрируются в AppCtx с областью видимости - доступны для всем.
Создаётся контейнер под бандл со своим класс-лоадером, парентом для которого является рутовый приложения.
Признак бандла - это jar в котором лежит сервис.
Регистрационная запись - это: API class - serviceName - bundleName - bundleVersion - reference_to_access_list_to_plugin -> имя jar + путь к классу + BUNDLE_CONTAINER.

Все бандлы из core_bundles загружаются согласно политики сервисов в них входящий.
Загрузка состоит из:
- если есть сервисы EAGER
- последовательно инстанцируются сервисы в рамках BUNDLE_CONTAINER (класс-лоадера)
- если сервис во время инстациации запрашивает другой сервис - ищу нужную регистрационную запись и начинаю грузить зависищий сервис
	(ТАК ЖЕ НЕОБХОДИМА ПОДДЕРЖКА ЛУПОВ ЗАГРУЗКИ)
- вызываем PostConstruct


4.3 Подгрузка плагинов.
Загрузка плагинов происходит из plugins каталога.
Все плагины регистрируются в AppCtx с областью видимости:
- доступны всем - те сервисы, которые экспортит плагин
- ограниченный доступ - для всех остальных сервисов, присутствующих в плагине
	Для этого нужно предварительно создать контейнеры бандлов для экспортируемых бандлов, чтобы были класс лоадеры.
	+ Нужна таблица соотвествия BUNDLE_CONTAINER(класс-лоадера) - плагин.
	в reference_to_access_list_to_plugin помещаем название плагина, которому разрешён доступ.
	Когда приходит call на инстанс сервиса - идём по стеку вызова вверх, берём каждый класс лоадер текущего класса - ищем для него название плагина,
	как нашли - смотрю есть ли этот плагин в списке разрешённых - если нет - ServiceAccessException.
Таким образом решается задача разграничения прав доступа к бандлам.
- вызываем PostConstruct


4.3 Жизненный цикл приложения
- AppCtx грузит core бандлы
- AppCtx грузит все плагины
- Делаем топографическую сортировку полученного графа
- Вызываем PostConstruct

4.4 Замечания по реализации логики:
Приложение после прогрузки и старта всех EAGER сервисов блокирует main поток AppCtx и вешает ShutdownHook на завершение программы.
Когда приложение получает сигнал о завершении, оно в обратной топологической сортировке начинает вызывать PreDestroy всем eager сервисам и завершается.

5. Общие библиотеки
С одной стороны если каждый плагин будет иметь собственный набор сторонних библиотек - это хорошо, т.к.
не будет пересечения с другими плагинами, если вдруг те используют другую версию.
Но с другой стороны будет оверхед на загрузку этих библиотек.
Можно так же сделать как и у storm или же apache tomcat. Если есть общие библиотеки - подложить их
в специяальный каталог приложения lib уже на стадии установки.


6. Правила декларации зависимостей градла в модулях:

6.1 Для API модулей:
Модуль апи должен иметь как можно меньше зависимостей от сторонних либ, не должен зависеть от других модулей проекта, за исключением
других апи модулей.

Декларация других апи модулей: api
Декларация 3-rd библиотек: api


6.2 Для бандлов:
Модуль с реализацией какого-либо апи  бандла. Такой бадл и выставляет данное апи.
Так же он подключает другие апи для взаимодействия с системой и с другими бандлами,
коммон библиотеки, 3-rd party библиотеки.

Декларация реализуемого API: api
Декларация API для взаимодействия с системой: implementation
Декларация коммон библиотек и сторонних: implementation


6.3 Для плагинов:
Модуль декларирует те бандлы которые он экспортирует.
Так же у него есть бандлы которые необходимы для его реализации.
Коммон библиотеки, 3-rd party библиотеки.
И так же есть зависимости от других плагинов.

Декларация экспортируемых бандлов и их API соответсвенно: api project(':bundles:neural-network-core')
Декларация бандлов с реализацией, необходимых для взаимодействия с ними экспортируемых бандлов и включённых в поставку плагина: implementation project(':bundles:comprehensive-serializer:1.0-SNAPSHOT')
Декларация зависимости от других плагинов (не обязательно включённых в проект, их могут написать другие команды): TODO


6.3 Для программ:
Модуль декларирует те core и framework бандлы, образующие самодостаточное приложение (без плагинов).
Коммон библиотеки, 3-rd party библиотеки, т.к. может иметь свой код запуска.
Так же включает project(':applications:application-starter') (так же там влючены и ресурсы различные, скрипты запуска и т.п.)

Декларация framework бандлов: implementation
Декларация коммон и 3-rd party библиотек: implementation
Декларация зависимости на стартер: implementation project(':applications:application-starter')



















