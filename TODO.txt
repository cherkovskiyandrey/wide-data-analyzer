- Пишем градл плагин, который в манифест выкидывает все сервисы которые экспортирует бандл. (+)
- Реализовать возможность внутри-бандового DI на уровне BundlePackager плагина (+)
- Подумать и отписать как быть со стандартными интерфейсами типа Runnable - public или private доступ? (+)
- Для api зависимостей, которые бандл реализует - accessType будет public,
  а для всех остальных, в том числе и implemented и стандартные java интерфейсы
   и транзитивные зависимости api - private (доступ только внутри бандла) (+)
- Продумать расположение 3-rd party библиотек (+)
- Реализовать dependency-management плагин для проверки зависемостей против dependencyManagement списка (+)
- В манифест бандла указать все зависимости ему необходимые для запуска в том числе и api (+)
- предать dependency-management консультационных характер (+)
- Поддержать возможность embedded зависимостей на уровне бандла (+)
- Обобщить подключение плагина bundle-packager для всех бандлов (+)
- Начать разработку application-packager плагина (+)
	* Разработать струкуру gradle.build файла (+)
	* Натравить bundle плагин на код программы (+)
	* Подключить из плагина bundle-packager (+)
- application-packager: разработка статических ресурсов (каталоги, скрипты....) (+)
- BUG: если почистить проект и собрать только лишь nn бандл, то он не собирётся (+)
	* во время выполнения Jar таски ещё не доступны проектные артефакты зависимостей
	* project.getTasks().getAt("build").doLast(new Action<Task>() {
- сделать buildSrc как мультипроект и включить в него необходимые подпроекты главного проекта (+)
- переписать BundleArchiver с использованием vfs (+)
- в бандл плагине реализовать ___all_api___ конфигурацию (+)
- разрезолвить ___all_api___ и сопоставить с бандловской (+)
- написать api-dependency-checker - проверяем что зависим только от других api проектов и все сторонние либы входят в dependencyManagement (+)
- зафорсить именование групп, зафорсить набор подпроектных типов и проверить их общим валидатором (+)
	нельзя завязываться на проект, т.к. бандл может не лежать в проекте а быть написанным третьей стороной,
	а мы захотим собрать плагин или приложение с этим бандлом, его проекта у нас нет, только
	на правильны идентификатор можно положиться - нужно заложить на будущее (+)
- для bundle-packager embedded плагина layout должен быть такой же как и для приложения: api, lib\common, lib\wda, lib (+)
- зафорсить проектные пути, т.к. применение плагинов идёт именно по путям (+)
- исправить createAndInitStuffApiConfig (+)
- для бандла убрать из impl зависимостей common! (+)
- разделить api зависимости в манифесте на api-export и api-import (+)
- сопровождать в манифесте зависимость группой-именем-версией (+)
- отвязаться от хардкода проектных путей в плагинах градла - для возможности создавать потом бандлы и плагины из вне (+)
- application-packager: сбор всех бандлов, апи, сторонних либ, общих библиотек и их размещенние по каталогам (-)
	* перетащить и адаптировать vfs проект (+)
	* подключиться к vfs проекту (+)
	* вытащить все onboard бандл зависимости и положить их в core_bundles, а если бандл без embedded зависимостей,
		то вытащить транзитивные зависимости и положить соответственно по api, lib\common, lib\wda, lib  (+)
	* проблема с onboard - не все зависимости на момент build собрались!!!!!! (+)
		-> так же проверить как отрабатывает STUFF_ALL_API!!!!! (+) - тоже нет, но и не важно - там просто сопоставляем зависимости!
- application-packager: повторить логику createAndInitStuffApiConfig - только собрать уже все бандлы, в том числе и 3rd party бандлы,
вытащить из них api и 3rd party api, проверить checkDependenciesAgainst, кинуть ошибку (+)
    //TODO: gather all api not only from project but from 3rd bundles from maven repo.
    //for example, this bundles could embedded new api with new external common dependencies
    //this method could not get these dependencies and this class could not invoke checkDependenciesAgainst with this considerate.
- application-packager: ревизия не реализованных API с предупреждением (+)
- implementation project(':applications:application-starter') (+)




- оттестировать работу плагинов (-)
	* в бандл плагине дать имя таски, взять jar таску текущего бандла, сделать dependsOn от всех jar тасок внутренних проектов от которых он зависет
		и свою таску сделать doLast после jar таски (+)
	* убедиться что maven плагин корректно выкладывает артефакт в локал репо (+)
	* применить похожую схему для остальных плагинов (+)
	* CommonValidator должен выполнять проверки до бандл всех плагинов (+)
	* - com/cherkovskiy/gradle/plugin/bundle/BundlePlugin.java:127: .findFirst() //TODO: нужно поискать все зависимости!!!! (+) В ОСТАЛЬНЫХ МЕСТАХ!!!!
	* неверно патчиться стартер (+)
	* NullPointer (+)
	* проверить другие типы упаковки итогого артефакта (+)
	* все интерфейсы сервисов только private (+)
	* api export пустой для neural-network-core (+)
	* неверное имя итового артефакта: C:\Andrey\WORKSPACE\wide-data-analyzer\applications\misc\nn-example\build\libs\nn-example-1.0-SNAPSHOT.jar-app.dir (+)
	* Bundle must has at least one service. There are not any services in bundle: :applications:misc когда собираешь весь проект (+)
	* org.gradle.execution.taskpath.ProjectFinderByTaskPath$ProjectLookupException: Project 'assembleApplication' not found in project ':applications:misc:class-loading-test'. (-)



- описать и начать разработку application-context и application-starter (-)

- переименовать группу com.cherkovskiy на com.wide_data_analyzer (-)

- Начать разработку plugin-packager плагина (-)

- Hello world бандлы написать с различными вариантами DI и возможностью потом объединить их в плагины или в приложение (-)


- После сборки бандла вывести на экран сервисы которые он экспортит (-)

- Необходимо предусмотреть DI в рамках самого банда для удобства работы с кодом (-)

- Создать archetype для бандлов и программ через https://github.com/orctom/gradle-archetype-plugin (-)


- Описать архитектуру ApplicationContext с поддержкой микросервисной ServiceDiscovery логикой (-)